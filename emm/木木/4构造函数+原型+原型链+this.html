<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>666</title>
</head>

<body>

    <script>

        // 构造函数 和 普通函数 的区别：没 new 就是普通函数执行，有了 new 就产生构造函数的功能
        function Test() { }
        function test() { }



        // 函数也是对象
        function test2() { }
        test2.aaa = 3
        test2.bbb = function () { }





        // 原型： 原型是 function 对象的一个属性，它定义了构造函数制造出的公共祖先
        //       通过该构造函数产生的对象，可以继承该原型的属性和方法
        // 原型也是对象




        // 对象如何查看原型：   隐式属性 __proto__
        // 对象如何查看对象的构造函数：     constructor


        A.prototype.name = '1'
        function A(){}
        var a = new A()
        console.log( a.name )



        A.prototype.name = '1'
        function A(){}
        var a = new A()
        A.prototype.name = '2'
        console.log( a.name )



        A.prototype.name = '1'
        function A(){}
        var a = new A()
        A.prototype = { name: '2' }
        console.log( a.name )




        A.prototype.name = '1'
        function A(){}
        A.prototype = { name: '2' }
        var a = new A()
        console.log( a.name )









        Grand.prototype.aaa = '1'
        function Grand(){

        }

        var grand = new Grand()

        Father.prototype = grand
        function Father(){
            this.num = 100
        }

        var father = new Father()

        Son.prototype = father
        function Son(){
            this.bbb = '2'
        }

        var son = new Son()

        // son.num ++
        // father.num ???
        // son.num ???











        // new 的底层原理
        // 1，在函数的最顶部 var this = {}
            // var this = Object.create(Test.prototype)
        // 2，逐步执行函数内部
            // this.xxx = xxx
        // 3，在函数的最底部 return this








        // 预编译和全局作用域，this 指向 window
        // call apply 可以改变 this 的指向
        // obj.func()     func()里面的 this 指向 obj

        function test() { }
        test() // 底层是 test.call()
        // call 没传参数，或者传的 null 或 undefined， 运行环境就是 window





        

        function A(name, age) {
            // var this === obj
            this.name = name
            this.age = age
        }
        var a = new A('a1', 20)
        var obj = {}
        A.call(obj, 'a2', 22)





        var fullname = 'A';
        var obj = {
            fullname: 'B',
            prop: {
                fullname: 'C',
                getFullname: function () {
                    return this.fullname;
                }
            }
        };
        console.log(obj.prop.getFullname())
        var test = obj.prop.getFullname
        console.log(test())











        var name = '222'
        var a = {
            name: '111',
            say: function () {
                console.log(this.name)
            }
        }
        var fun = a.say
        fun()
        a.say()
        var b = {
            name: '333',
            say: function (fun) {
                fun()
            }
        }
        b.say(a.say)
        b.say = a.say
        b.say()






        
        function Foo() {
            Foo.a = function () {
                console.log(1)
            }
            this.a = function () {
                console.log(2)
            }
        }
        Foo.prototype.a = function () {
            console.log(3)
        }
        Foo.a = function () {
            console.log(4)
        }
        Foo.a();
        let obj = new Foo();
        obj.a();
        Foo.a();



    </script>

</body>

</html>